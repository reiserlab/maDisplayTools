function generate_g6_encoding_reference(output_file)
% GENERATE_G6_ENCODING_REFERENCE Generate JSON reference data for G6 encoding validation
%
% This script generates reference encoding data using the MATLAB g6_encode_panel
% function, which can be used to validate the JavaScript implementation in
% webDisplayTools.
%
% Usage:
%   generate_g6_encoding_reference()                    % Default output
%   generate_g6_encoding_reference('my_reference.json') % Custom output
%
% Output:
%   JSON file containing test vectors and pattern encodings

if nargin < 1
    output_file = 'g6_encoding_reference.json';
end

fprintf('Generating G6 encoding reference data...\n\n');

% Initialize output structure
ref = struct();
ref.generated = datestr(now, 'yyyy-mm-dd HH:MM:SS');
ref.source = 'MATLAB g6_encode_panel.m';
ref.encoding_convention = struct(...
    'origin', 'bottom-left', ...
    'ordering', 'row-major', ...
    'formula', 'pixel_num = row_from_bottom * 20 + col', ...
    'gs2_bit_order', 'MSB-first (bit 7 = first pixel in byte)', ...
    'gs16_nibble_order', 'high nibble = even pixel, low nibble = odd pixel' ...
);

%% Generate Single Pixel Test Vectors
fprintf('Generating single pixel test vectors...\n');

test_vectors = {};

% Test 1: Single pixel at (0,0) bottom-left
% In our convention: row 0 = bottom, so MATLAB row 20 (index 20)
pixels = zeros(20, 20, 'uint8');
pixels(20, 1) = 1;  % MATLAB row 20, col 1 = panel (0,0)
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(20, 1) = 15;  % Max intensity
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'single_pixel_00', ...
    'description', 'Single pixel at (0,0) bottom-left', ...
    'panel_row', 0, ...
    'panel_col', 0, ...
    'matlab_row', 20, ...
    'matlab_col', 1, ...
    'pixel_num', 0, ...
    'gs2_value', 1, ...
    'gs16_value', 15, ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 2: Single pixel at (0,1)
pixels = zeros(20, 20, 'uint8');
pixels(20, 2) = 1;  % MATLAB row 20, col 2 = panel (0,1)
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(20, 2) = 15;
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'single_pixel_01', ...
    'description', 'Single pixel at (0,1)', ...
    'panel_row', 0, ...
    'panel_col', 1, ...
    'matlab_row', 20, ...
    'matlab_col', 2, ...
    'pixel_num', 1, ...
    'gs2_value', 1, ...
    'gs16_value', 15, ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 3: Single pixel at (0,19) bottom-right
pixels = zeros(20, 20, 'uint8');
pixels(20, 20) = 1;  % MATLAB row 20, col 20 = panel (0,19)
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(20, 20) = 15;
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'single_pixel_0_19', ...
    'description', 'Single pixel at (0,19) bottom-right', ...
    'panel_row', 0, ...
    'panel_col', 19, ...
    'matlab_row', 20, ...
    'matlab_col', 20, ...
    'pixel_num', 19, ...
    'gs2_value', 1, ...
    'gs16_value', 15, ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 4: Single pixel at (19,0) top-left
pixels = zeros(20, 20, 'uint8');
pixels(1, 1) = 1;  % MATLAB row 1, col 1 = panel (19,0)
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(1, 1) = 15;
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'single_pixel_19_0', ...
    'description', 'Single pixel at (19,0) top-left', ...
    'panel_row', 19, ...
    'panel_col', 0, ...
    'matlab_row', 1, ...
    'matlab_col', 1, ...
    'pixel_num', 380, ...
    'gs2_value', 1, ...
    'gs16_value', 15, ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 5: Single pixel at (19,19) top-right
pixels = zeros(20, 20, 'uint8');
pixels(1, 20) = 1;  % MATLAB row 1, col 20 = panel (19,19)
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(1, 20) = 15;
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'single_pixel_19_19', ...
    'description', 'Single pixel at (19,19) top-right', ...
    'panel_row', 19, ...
    'panel_col', 19, ...
    'matlab_row', 1, ...
    'matlab_col', 20, ...
    'pixel_num', 399, ...
    'gs2_value', 1, ...
    'gs16_value', 15, ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 6: Two adjacent pixels (0,0) and (0,1)
pixels = zeros(20, 20, 'uint8');
pixels(20, 1) = 1;
pixels(20, 2) = 1;
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

pixels_gs16 = zeros(20, 20, 'uint8');
pixels_gs16(20, 1) = 15;
pixels_gs16(20, 2) = 10;
block_gs16 = g6_encode_panel(pixels_gs16, 192, 'GS16');

test_vectors{end+1} = struct(...
    'name', 'two_adjacent_pixels', ...
    'description', 'Two adjacent pixels at (0,0) and (0,1)', ...
    'gs2_value', 1, ...
    'gs16_values', [15, 10], ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2'), ...
    'gs16_bytes', extract_data_bytes(block_gs16, 'GS16') ...
);

% Test 7: Bottom row lit (row 0)
pixels = zeros(20, 20, 'uint8');
pixels(20, :) = 1;  % MATLAB row 20 = panel row 0
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

test_vectors{end+1} = struct(...
    'name', 'bottom_row_lit', ...
    'description', 'Bottom row (row 0) all lit', ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2') ...
);

% Test 8: Left column lit (col 0)
pixels = zeros(20, 20, 'uint8');
pixels(:, 1) = 1;  % MATLAB col 1 = panel col 0
block_gs2 = g6_encode_panel(pixels, 192, 'GS2');

test_vectors{end+1} = struct(...
    'name', 'left_column_lit', ...
    'description', 'Left column (col 0) all lit', ...
    'gs2_bytes', extract_data_bytes(block_gs2, 'GS2') ...
);

ref.test_vectors = test_vectors;

%% Generate Pattern Encodings
fprintf('Generating pattern encodings...\n');

patterns = struct();

% GS2 Patterns (matching JavaScript GS2_PATTERNS)

% all_off
pixels = zeros(20, 20, 'uint8');
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.all_off = struct(...
    'description', 'All LEDs off', ...
    'mode', 'GS2', ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% all_on
pixels = ones(20, 20, 'uint8');
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.all_on = struct(...
    'description', 'All LEDs on', ...
    'mode', 'GS2', ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% border
pixels = zeros(20, 20, 'uint8');
pixels(1, :) = 1;   % Top row (MATLAB row 1 = panel row 19)
pixels(20, :) = 1;  % Bottom row (MATLAB row 20 = panel row 0)
pixels(:, 1) = 1;   % Left column
pixels(:, 20) = 1;  % Right column
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.border = struct(...
    'description', 'Border frame (rows/columns 0 and 19)', ...
    'mode', 'GS2', ...
    'pixel_matrix', double(pixels), ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% cross
pixels = zeros(20, 20, 'uint8');
pixels(10, :) = 1;  % MATLAB row 10 = panel row 10
pixels(11, :) = 1;  % MATLAB row 11 = panel row 9
pixels(:, 10) = 1;  % col 9
pixels(:, 11) = 1;  % col 10
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.cross = struct(...
    'description', 'Cross pattern (rows/cols 9-10)', ...
    'mode', 'GS2', ...
    'pixel_matrix', double(pixels), ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% checker_2x2
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    for c = 1:20
        % Panel row = 19 - (matlab_row - 1) = 20 - matlab_row
        panel_row = 20 - r;
        panel_col = c - 1;
        if mod(floor(panel_row/2) + floor(panel_col/2), 2) == 0
            pixels(r, c) = 1;
        end
    end
end
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.checker_2x2 = struct(...
    'description', '2x2 checkerboard pattern', ...
    'mode', 'GS2', ...
    'pixel_matrix', double(pixels), ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% horiz_stripes (every 4 rows)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    panel_row = 20 - r;  % Convert to panel coordinates
    if mod(panel_row, 4) == 0
        pixels(r, :) = 1;
    end
end
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.horiz_stripes = struct(...
    'description', 'Horizontal stripes every 4 rows', ...
    'mode', 'GS2', ...
    'pixel_matrix', double(pixels), ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% vert_stripes (every 4 columns)
pixels = zeros(20, 20, 'uint8');
for c = 1:20
    panel_col = c - 1;
    if mod(panel_col, 4) == 0
        pixels(:, c) = 1;
    end
end
block = g6_encode_panel(pixels, 192, 'GS2');
patterns.vert_stripes = struct(...
    'description', 'Vertical stripes every 4 columns', ...
    'mode', 'GS2', ...
    'pixel_matrix', double(pixels), ...
    'gs2_bytes', extract_data_bytes(block, 'GS2') ...
);

% GS16 Patterns

% gradient_h (horizontal gradient, intensity varies by row)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    panel_row = 20 - r;  % Panel coordinates
    intensity = floor(panel_row / 19 * 15);
    pixels(r, :) = intensity;
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.gradient_h = struct(...
    'description', 'Horizontal gradient (intensity by row)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% gradient_v (vertical gradient, intensity varies by column)
pixels = zeros(20, 20, 'uint8');
for c = 1:20
    panel_col = c - 1;
    intensity = floor(panel_col / 19 * 15);
    pixels(:, c) = intensity;
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.gradient_v = struct(...
    'description', 'Vertical gradient (intensity by column)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% gradient_diag (diagonal gradient)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    for c = 1:20
        panel_row = 20 - r;
        panel_col = c - 1;
        intensity = min(15, floor((panel_row + panel_col) / 38 * 15));
        pixels(r, c) = intensity;
    end
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.gradient_diag = struct(...
    'description', 'Diagonal gradient', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% concentric_bright (center bright, edges dark)
pixels = zeros(20, 20, 'uint8');
center_r = 9.5;
center_c = 9.5;
max_dist = sqrt(center_r^2 + center_c^2);
for r = 1:20
    for c = 1:20
        panel_row = 20 - r;
        panel_col = c - 1;
        dist = sqrt((panel_row - center_r)^2 + (panel_col - center_c)^2);
        intensity = max(0, min(15, 15 - floor(dist / max_dist * 16)));
        pixels(r, c) = intensity;
    end
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.concentric_bright = struct(...
    'description', 'Concentric bright (center bright)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% concentric_dark (center dark, edges bright)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    for c = 1:20
        panel_row = 20 - r;
        panel_col = c - 1;
        dist = sqrt((panel_row - center_r)^2 + (panel_col - center_c)^2);
        intensity = min(15, floor(dist / max_dist * 16));
        pixels(r, c) = intensity;
    end
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.concentric_dark = struct(...
    'description', 'Concentric dark (center dark)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% checkerboard_intensity (4x4 blocks, alternating 15 and 5)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    for c = 1:20
        panel_row = 20 - r;
        panel_col = c - 1;
        if mod(floor(panel_row/4) + floor(panel_col/4), 2) == 0
            pixels(r, c) = 15;
        else
            pixels(r, c) = 5;
        end
    end
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.checkerboard_intensity = struct(...
    'description', 'Checkerboard intensity (15/5)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

% spotlight (exponential falloff from center)
pixels = zeros(20, 20, 'uint8');
for r = 1:20
    for c = 1:20
        panel_row = 20 - r;
        panel_col = c - 1;
        dist = sqrt((panel_row - center_r)^2 + (panel_col - center_c)^2);
        intensity = max(0, min(15, floor(15 * exp(-3 * dist / max_dist))));
        pixels(r, c) = intensity;
    end
end
block = g6_encode_panel(pixels, 192, 'GS16');
patterns.spotlight = struct(...
    'description', 'Spotlight (exponential falloff)', ...
    'mode', 'GS16', ...
    'pixel_matrix', double(pixels), ...
    'gs16_bytes', extract_data_bytes(block, 'GS16') ...
);

ref.patterns = patterns;

%% Write JSON file
fprintf('Writing JSON file: %s\n', output_file);

json_str = jsonencode(ref);
% Pretty print (basic formatting)
json_str = strrep(json_str, ',"', sprintf(',\n"'));
json_str = strrep(json_str, '{', sprintf('{\n'));
json_str = strrep(json_str, '}', sprintf('\n}'));

fid = fopen(output_file, 'w');
fprintf(fid, '%s', json_str);
fclose(fid);

fprintf('\nDone! Generated %d test vectors and %d patterns.\n', ...
    length(test_vectors), length(fieldnames(patterns)));
fprintf('Copy this file to webDisplayTools/data/g6_encoding_reference.json\n');

end

%% Helper function to extract data bytes from panel block
function bytes = extract_data_bytes(block, mode)
    % Extract just the data bytes (skip header and command)
    % GS2: bytes 3-52 (50 data bytes)
    % GS16: bytes 3-202 (200 data bytes)

    if strcmp(mode, 'GS2')
        bytes = double(block(3:52));  % Convert to double for JSON
    else
        bytes = double(block(3:202));
    end
end
