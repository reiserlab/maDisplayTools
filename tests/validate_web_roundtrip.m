function results = validate_web_roundtrip()
%VALIDATE_WEB_ROUNDTRIP Test Web → MATLAB pattern roundtrip
%
%   results = validate_web_roundtrip() loads .pat files generated by the
%   web PatEncoder (webDisplayTools) and verifies pixel-exact correctness
%   against deterministic reference patterns.
%
%   Prerequisites:
%     Run the web pattern generator first:
%       cd webDisplayTools
%       node tests/generate-roundtrip-patterns.js --outdir ../maDisplayTools/patterns/web_generated
%
%   Returns:
%       results - struct with fields:
%           passed (logical): true if all tests passed
%           num_passed (int): number of tests passed
%           num_total (int): total number of tests
%           details (cell array): detailed results for each test

    fprintf('=== Web → MATLAB Roundtrip Validation ===\n\n');

    % Get maDisplayTools root
    maDisplayToolsRoot = fileparts(fileparts(mfilename('fullpath')));

    % Path to web-generated patterns
    webPatsDir = fullfile(maDisplayToolsRoot, 'patterns', 'web_generated');
    manifestFile = fullfile(webPatsDir, 'web_generated_manifest.json');

    if ~exist(manifestFile, 'file')
        error(['Manifest not found: %s\n' ...
               'Run: node tests/generate-roundtrip-patterns.js --outdir ../maDisplayTools/patterns/web_generated'], ...
               manifestFile);
    end

    % Load manifest
    manifestText = fileread(manifestFile);
    manifest = jsondecode(manifestText);
    patterns = manifest.patterns;
    num_tests = length(patterns);

    test_results = false(num_tests, 1);
    test_details = cell(num_tests, 1);

    for i = 1:num_tests
        p = patterns(i);
        fprintf('Test %d/%d: %s\n', i, num_tests, p.filename);
        fprintf('  %s, %dx%d, %d frames, arena_id=%d\n', ...
            p.generation, p.pixelRows, p.pixelCols, p.numFrames, p.arena_id);

        try
            % Load .pat file
            patFile = fullfile(webPatsDir, p.filename);
            if ~exist(patFile, 'file')
                error('Pattern file not found: %s', p.filename);
            end
            [frames, meta] = maDisplayTools.load_pat(patFile);

            % ── Verify metadata ──

            % Dimensions
            assert_equal('rows', meta.rows, p.pixelRows);
            assert_equal('cols', meta.cols, p.pixelCols);
            assert_equal('numFrames', meta.NumPatsX, p.numFrames);

            % Grayscale mode
            if p.gs_val == 2 || p.gs_val == 1
                expected_vmax = 1;
            else
                expected_vmax = 15;
            end
            assert_equal('vmax', meta.vmax, expected_vmax);

            % Header V2 metadata
            assert_equal('header_version', meta.header_version, 2);
            assert_equal('arena_id', meta.arena_id, p.arena_id);

            % Generation
            expected_gen = p.generation;
            % G4.1 may appear as 'G4.1' in meta
            if strcmp(p.generation, 'G4.1')
                expected_gen = 'G4.1';
            end
            if ~strcmp(meta.generation, expected_gen)
                error('generation: got ''%s'', expected ''%s''', meta.generation, expected_gen);
            end

            % ── Verify pixel data ──

            maxVal = p.maxVal;
            period = p.period;
            stepPixels = p.stepPixels;
            pixelRows = p.pixelRows;
            pixelCols = p.pixelCols;

            for f = 1:p.numFrames
                shift = (f - 1) * stepPixels;  % 0-indexed frame → shift

                % Generate expected frame using same formula as Node.js
                expected = generate_expected_frame(p.patternType, ...
                    pixelRows, pixelCols, period, shift, maxVal);

                % Extract loaded frame
                % frames is (NumPatsY, NumPatsX, rows, cols) — squeeze to (rows, cols)
                loaded = squeeze(frames(1, f, :, :));

                % Compare pixel-by-pixel
                if ~isequal(expected, loaded)
                    % Find first mismatch
                    diff_mask = (expected ~= loaded);
                    [mismatch_rows, mismatch_cols] = find(diff_mask, 1, 'first');
                    r = mismatch_rows(1);
                    c = mismatch_cols(1);
                    num_diff = sum(diff_mask(:));
                    error('Frame %d pixel mismatch at (%d,%d): loaded=%d, expected=%d (%d total mismatches)', ...
                        f, r, c, loaded(r,c), expected(r,c), num_diff);
                end
            end

            test_results(i) = true;
            test_details{i} = sprintf('%s: OK (%dx%d, %d frames, gs=%d)', ...
                p.filename, pixelRows, pixelCols, p.numFrames, p.gs_val);
            fprintf('  PASS\n');

        catch ME
            test_results(i) = false;
            test_details{i} = sprintf('%s: FAIL - %s', p.filename, ME.message);
            fprintf('  FAIL: %s\n', ME.message);
        end
    end

    % Summary
    num_passed = sum(test_results);
    fprintf('\n=== Summary ===\n');
    fprintf('Passed: %d / %d\n', num_passed, num_tests);

    if num_passed == num_tests
        fprintf('All tests PASSED!\n');
    else
        fprintf('FAILED tests:\n');
        for i = 1:num_tests
            if ~test_results(i)
                fprintf('  - %s\n', test_details{i});
            end
        end
    end

    results = struct(...
        'passed', num_passed == num_tests, ...
        'num_passed', num_passed, ...
        'num_total', num_tests, ...
        'details', {test_details});
end


function assert_equal(name, actual, expected)
    if actual ~= expected
        error('%s: got %d, expected %d', name, actual, expected);
    end
end


function frame = generate_expected_frame(patternType, pixelRows, pixelCols, period, shift, maxVal)
%GENERATE_EXPECTED_FRAME Recreate deterministic pattern matching Node.js formulas
%
%   These formulas must EXACTLY match the JavaScript functions in
%   webDisplayTools/tests/generate-roundtrip-patterns.js

    frame = zeros(pixelRows, pixelCols, 'uint8');

    switch patternType
        case 'squareGrating'
            % pixel[r][c] = ((c + shift) % period < period/2) ? maxVal : 0
            for r = 1:pixelRows
                for c = 1:pixelCols
                    c0 = c - 1;  % 0-indexed column
                    phase = mod(c0 + shift, period);
                    if phase < period / 2
                        frame(r, c) = maxVal;
                    end
                end
            end

        case 'sineGrating'
            % pixel[r][c] = round(maxVal * (0.5 + 0.5 * sin(2π * (c + shift) / period)))
            for r = 1:pixelRows
                for c = 1:pixelCols
                    c0 = c - 1;  % 0-indexed column
                    val = round(maxVal * (0.5 + 0.5 * sin(2 * pi * (c0 + shift) / period)));
                    frame(r, c) = min(maxVal, max(0, val));
                end
            end

        case 'horizontalGrating'
            % pixel[r][c] = ((r + shift) % period < period/2) ? maxVal : 0
            for r = 1:pixelRows
                r0 = r - 1;  % 0-indexed row
                phase = mod(r0 + shift, period);
                if phase < period / 2
                    val = maxVal;
                else
                    val = 0;
                end
                for c = 1:pixelCols
                    frame(r, c) = val;
                end
            end

        case 'checkerboard'
            % pixel[r][c] = ((floor((r+shift)/block) + floor(c/block)) % 2 == 0) ? maxVal : 0
            % Note: in JS, (r+shift) wraps via modulo of pixelRows
            blockSize = period;  % period == blockSize for checkerboard
            for r = 1:pixelRows
                r0 = r - 1;
                for c = 1:pixelCols
                    c0 = c - 1;
                    rWrapped = mod(r0 + shift, pixelRows);
                    rBlock = floor(rWrapped / blockSize);
                    cBlock = floor(c0 / blockSize);
                    if mod(rBlock + cBlock, 2) == 0
                        frame(r, c) = maxVal;
                    end
                end
            end

        otherwise
            error('Unknown pattern type: %s', patternType);
    end
end
